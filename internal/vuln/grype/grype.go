package grype

import (
	"fmt"
	"os"

	"github.com/anchore/grype/grype"
	"github.com/anchore/grype/grype/db"
	v3 "github.com/anchore/grype/grype/db/v3"
	"github.com/anchore/grype/grype/match"
	"github.com/anchore/grype/grype/pkg"
	"github.com/anchore/grype/grype/vulnerability"
	"github.com/anchore/syft/syft/pkg/cataloger"
	"github.com/ckotzbauer/vulnerability-operator/internal/vuln/source"
	"github.com/sirupsen/logrus"
)

type Grype struct {
}

func New() Grype {
	return Grype{}
}

func (s *Grype) ScanSbom(sbom source.Sbom) ([]Vulnerability, error) {
	// TODO: Only load DB initially
	// TODO: Try to avoid storing SBOM on FS

	err := os.WriteFile("/tmp/sbom", []byte(sbom.Sbom), 0640)
	if err != nil {
		logrus.WithError(err).Error("SBOM could not be saved")
		return []Vulnerability{}, err
	}

	config := db.Config{
		ListingURL: "https://toolbox-data.anchore.io/grype/databases/listing.json",
		DBRootDir:  "/tmp/grype/db",
	}

	logrus.Debug("Load vulnerability database")
	provider, metadataProvider, dbStatus, err := grype.LoadVulnerabilityDB(config, true)
	if err = validateDBLoad(err, dbStatus); err != nil {
		logrus.WithError(err).Error()
		return []Vulnerability{}, err
	}

	providerConfig := pkg.ProviderConfig{
		CatalogingOptions: cataloger.DefaultConfig(),
	}

	packages, context, err := pkg.Provide("sbom:/tmp/sbom", providerConfig)
	os.Remove("/tmp/sbom")
	if err != nil {
		logrus.WithError(fmt.Errorf("failed to catalog: %w", err)).Error()
		return []Vulnerability{}, err
	}

	allMatches := grype.FindVulnerabilitiesForPackage(provider, context.Distro, packages...)
	vulns := buildVulnerabilities(allMatches, metadataProvider)
	return vulns, nil
}

func validateDBLoad(loadErr error, status *db.Status) error {
	if loadErr != nil {
		return fmt.Errorf("failed to load vulnerability db: %w", loadErr)
	}
	if status == nil {
		return fmt.Errorf("unable to determine DB status")
	}
	if status.Err != nil {
		return fmt.Errorf("db could not be loaded: %w", status.Err)
	}
	return nil
}

func buildVulnerabilities(matches match.Matches, metadataProvider vulnerability.MetadataProvider) []Vulnerability {
	vulnerabilities := make([]Vulnerability, 0)

	for m := range matches.Enumerate() {
		metadata, err := metadataProvider.GetMetadata(m.Vulnerability.ID, m.Vulnerability.Namespace)
		if err != nil {
			continue
		}

		fixedIn := []string{}
		if m.Vulnerability.Fix.State == v3.FixedState {
			fixedIn = m.Vulnerability.Fix.Versions
		}

		vulnerabilities = append(vulnerabilities, Vulnerability{
			ID:        m.Vulnerability.ID,
			Severity:  metadata.Severity,
			Type:      string(m.Package.Type),
			Package:   m.Package.Name,
			Installed: m.Package.Version,
			FixedIn:   fixedIn,
			FixState:  string(m.Vulnerability.Fix.State),
			URLs:      metadata.URLs,
		})
	}

	return vulnerabilities
}

package grype

import (
	"fmt"
	"os"

	"github.com/anchore/grype/grype"
	"github.com/anchore/grype/grype/db"
	v3 "github.com/anchore/grype/grype/db/v3"
	"github.com/anchore/grype/grype/match"
	"github.com/anchore/grype/grype/pkg"
	"github.com/anchore/grype/grype/vulnerability"
	"github.com/anchore/syft/syft/pkg/cataloger"
	"github.com/ckotzbauer/vulnerability-operator/internal/vuln"
	"github.com/ckotzbauer/vulnerability-operator/internal/vuln/kubernetes"
	"github.com/ckotzbauer/vulnerability-operator/internal/vuln/source"
	"github.com/sirupsen/logrus"
	"github.com/spf13/viper"
)

type Grype struct {
	provider         vulnerability.Provider
	metadataProvider vulnerability.MetadataProvider
	kubeClient       *kubernetes.KubeClient
}

func New() Grype {
	config := db.Config{
		ListingURL: "https://toolbox-data.anchore.io/grype/databases/listing.json",
		DBRootDir:  "/tmp/grype/db",
	}

	logrus.Debug("Load vulnerability database")
	provider, metadataProvider, dbStatus, err := grype.LoadVulnerabilityDB(config, true)
	if err = validateDBLoad(err, dbStatus); err != nil {
		logrus.Error(err)
		return Grype{}
	}

	client := kubernetes.NewClient()

	return Grype{provider: provider, metadataProvider: metadataProvider, kubeClient: client}
}

func (s *Grype) ScanSbom(sbom source.Sbom) ([]Vulnerability, error) {
	// TODO: Try to avoid storing SBOM on FS

	err := os.WriteFile("/tmp/sbom", []byte(sbom.Sbom), 0640)
	if err != nil {
		logrus.WithError(err).Error("SBOM could not be saved")
		return []Vulnerability{}, err
	}

	providerConfig := pkg.ProviderConfig{
		CatalogingOptions: cataloger.DefaultConfig(),
	}

	packages, context, err := pkg.Provide("sbom:/tmp/sbom", providerConfig)
	os.Remove("/tmp/sbom")
	if err != nil {
		logrus.WithError(fmt.Errorf("failed to catalog: %w", err)).Error()
		return []Vulnerability{}, err
	}

	allMatches := grype.FindVulnerabilitiesForPackage(s.provider, context.Distro, packages...)
	vulns := s.buildVulnerabilities(allMatches, sbom.ImageID)
	return filterVulnerabilities(vulns), nil
}

func validateDBLoad(loadErr error, status *db.Status) error {
	if loadErr != nil {
		return fmt.Errorf("failed to load vulnerability db: %w", loadErr)
	}
	if status == nil {
		return fmt.Errorf("unable to determine DB status")
	}
	if status.Err != nil {
		return fmt.Errorf("db could not be loaded: %w", status.Err)
	}
	return nil
}

func (s *Grype) buildVulnerabilities(matches match.Matches, imageID string) []Vulnerability {
	vulnerabilities := make([]Vulnerability, 0)

	for m := range matches.Enumerate() {
		metadata, err := s.metadataProvider.GetMetadata(m.Vulnerability.ID, m.Vulnerability.Namespace)
		if err != nil {
			continue
		}

		fixedIn := []string{}
		if m.Vulnerability.Fix.State == v3.FixedState {
			fixedIn = m.Vulnerability.Fix.Versions
		}

		infos, _ := s.kubeClient.GetContainersWithImage(imageID)
		vulnerabilities = append(vulnerabilities, Vulnerability{
			ID:         m.Vulnerability.ID,
			Severity:   metadata.Severity,
			Type:       string(m.Package.Type),
			Package:    m.Package.Name,
			Installed:  m.Package.Version,
			FixedIn:    fixedIn,
			FixState:   string(m.Vulnerability.Fix.State),
			URLs:       metadata.URLs,
			ImageID:    imageID,
			Containers: infos,
		})
	}

	return vulnerabilities
}

func filterVulnerabilities(allVulns []Vulnerability) []Vulnerability {
	onlyFixed := viper.GetBool(vuln.ConfigKeyOnlyFixed)
	minSeverity := vulnerability.ParseSeverity(viper.GetString(vuln.ConfigKeyMinSeverity))

	vulns := make([]Vulnerability, 0)

	for _, v := range allVulns {
		sev := vulnerability.ParseSeverity(v.Severity)
		if sev >= minSeverity {
			if onlyFixed {
				if v.FixState == string(v3.FixedState) {
					vulns = append(vulns, v)
				}
			} else {
				vulns = append(vulns, v)
			}
		}
	}

	return vulns
}

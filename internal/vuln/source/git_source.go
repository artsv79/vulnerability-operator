package source

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/ckotzbauer/vulnerability-operator/internal/vuln"
	"github.com/ckotzbauer/vulnerability-operator/internal/vuln/source/git"
	"github.com/sirupsen/logrus"
	"github.com/spf13/viper"
)

type GitSource struct {
	workingTree string
	workPath    string
	repository  string
	branch      string
	gitAccount  git.GitAccount
	sboms       []Sbom
}

func NewGitSource() *GitSource {
	workingTree := viper.GetString(vuln.ConfigKeyGitWorkingTree)
	workPath := viper.GetString(vuln.ConfigKeyGitPath)
	repository := viper.GetString(vuln.ConfigKeyGitRepository)
	branch := viper.GetString(vuln.ConfigKeyGitBranch)

	gitAccount := git.New(viper.GetString(vuln.ConfigKeyGitAccessToken))

	return &GitSource{
		workingTree: workingTree,
		workPath:    workPath,
		repository:  repository,
		branch:      branch,
		gitAccount:  gitAccount,
		sboms:       []Sbom{},
	}
}

func (g *GitSource) ValidateConfig() error {
	if g.workingTree == "" {
		return fmt.Errorf("%s is empty", vuln.ConfigKeyGitWorkingTree)
	}

	if g.repository == "" {
		return fmt.Errorf("%s is empty", vuln.ConfigKeyGitRepository)
	}

	if g.branch == "" {
		return fmt.Errorf("%s is empty", vuln.ConfigKeyGitBranch)
	}

	if g.gitAccount.Token == "" {
		return fmt.Errorf("%s is empty", vuln.ConfigKeyGitAccessToken)
	}

	return nil
}

func (g *GitSource) Initialize() {
	g.gitAccount.PrepareRepository(
		g.repository, g.workingTree,
		viper.GetString(vuln.ConfigKeyGitBranch))
}

func (g *GitSource) LoadSboms() []Sbom {
	g.sboms = []Sbom{}
	ignoreDirs := []string{".git"}
	sbomFileNames := []string{"sbom.json", "sbom.txt", "sbom.xml", "sbom.spdx"}
	err := filepath.Walk(filepath.Join(g.workingTree, g.workPath), g.filterSboms(ignoreDirs, sbomFileNames))
	if err != nil {
		logrus.WithError(err).Error("Could load SBOMs")
	}

	return g.sboms
}

func (g *GitSource) filterSboms(ignoreDirs, sbomFileNames []string) filepath.WalkFunc {
	return func(p string, info os.FileInfo, err error) error {
		if err != nil {
			logrus.WithError(err).Errorf("An error occurred while processing %s", p)
			return nil
		}

		if info.IsDir() {
			dir := filepath.Base(p)
			for _, d := range ignoreDirs {
				if d == dir {
					return filepath.SkipDir
				}
			}
		}

		file := filepath.Base(p)
		for _, f := range sbomFileNames {
			if f == file {
				content, err := os.ReadFile(p)
				if err != nil {
					logrus.WithError(err).Errorf("An error occurred while reading file %s", p)
					continue
				}

				imageID := g.extractImageIDFromFile(p)
				sbom := Sbom{Sbom: string(content), ImageID: imageID}
				g.sboms = append(g.sboms, sbom)
			}
		}

		return nil
	}
}

func (g *GitSource) extractImageIDFromFile(f string) string {
	cleaned, _ := filepath.Rel(g.workingTree, f)
	cleaned, _ = filepath.Rel(g.workPath, cleaned)
	cleaned = strings.Replace(cleaned, "/sha256_", "@sha256:", 1)
	cleaned = filepath.Dir(cleaned)
	return cleaned
}

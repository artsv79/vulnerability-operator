package daemon

import (
	"time"

	"github.com/ckotzbauer/vulnerability-operator/internal/vuln"
	"github.com/ckotzbauer/vulnerability-operator/internal/vuln/grype"
	"github.com/ckotzbauer/vulnerability-operator/internal/vuln/source"
	"github.com/ckotzbauer/vulnerability-operator/internal/vuln/target"
	"github.com/robfig/cron"
	"github.com/sirupsen/logrus"
	"github.com/spf13/viper"
)

type CronService struct {
	cron    string
	sources []source.Source
	targets []target.Target
}

var running = false

func Start(cronTime string) {
	cr := vuln.Unescape(cronTime)
	sourceKeys := viper.GetStringSlice(vuln.ConfigKeySources)
	targetKeys := viper.GetStringSlice(vuln.ConfigKeyTargets)

	logrus.Debugf("Cron set to: %v", cr)
	logrus.Debugf("Sources set to: %v", sourceKeys)
	logrus.Debugf("Targets set to: %v", targetKeys)

	sources := initSources(sourceKeys)
	targets := initTargets(targetKeys)
	cs := CronService{cron: cr, sources: sources, targets: targets}
	cs.printNextExecution()

	c := cron.New()
	c.AddFunc(cr, func() { cs.runBackgroundService() })
	c.Start()
}

func (c *CronService) printNextExecution() {
	s, err := cron.Parse(c.cron)
	if err != nil {
		logrus.WithError(err).Fatal("Cron cannot be parsed")
	}

	nextRun := s.Next(time.Now())
	logrus.Debugf("Next background-service run at: %v", nextRun)
}

func (c *CronService) runBackgroundService() {
	if running {
		return
	}

	running = true

	logrus.Info("Execute background-service")
	sboms := []source.Sbom{}

	for _, s := range c.sources {
		s.Initialize()
		sboms = append(sboms, s.LoadSboms()...)
	}

	gr, err := grype.New()

	if err != nil {
		c.printNextExecution()
		running = false
		return
	}

	allVulns := make([]grype.Vulnerability, 0)

	for _, sbom := range sboms {
		vulns, err := gr.ScanSbom(sbom)

		if err == nil {
			// handle result
			allVulns = append(allVulns, vulns...)
		}
	}

	for _, t := range c.targets {
		t.Initialize()
		t.ProcessVulns(allVulns)
		t.Finalize()
	}

	c.printNextExecution()
	running = false
}

func initSources(sourceKeys []string) []source.Source {
	sources := make([]source.Source, 0)

	for _, sa := range sourceKeys {
		var err error

		if sa == "git" {
			s := source.NewGitSource()
			err = s.ValidateConfig()
			sources = append(sources, s)
		} else {
			logrus.Fatalf("Unknown source %s", sa)
		}

		if err != nil {
			logrus.WithError(err).Fatal("Config-Validation failed!")
		}
	}

	if len(sources) == 0 {
		logrus.Fatalf("Please specify at least one source.")
	}

	return sources
}

func initTargets(targetKeys []string) []target.Target {
	targets := make([]target.Target, 0)

	for _, ta := range targetKeys {
		var err error
		var t target.Target

		if ta == "json" {
			t = target.NewJsonTarget()
		} else if ta == "metrics" {
			t = target.NewMetricTarget()
		} else {
			logrus.Fatalf("Unknown target %s", ta)
		}

		err = t.ValidateConfig()
		targets = append(targets, t)

		if err != nil {
			logrus.WithError(err).Fatal("Config-Validation failed!")
		}
	}

	if len(targets) == 0 {
		logrus.Fatalf("Please specify at least one target.")
	}

	return targets
}

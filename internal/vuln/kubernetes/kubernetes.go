package kubernetes

import (
	"context"

	"github.com/sirupsen/logrus"
	corev1 "k8s.io/api/core/v1"
	meta "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/tools/clientcmd"
)

type KubeClient struct {
	Client *kubernetes.Clientset
	pods   []corev1.Pod
}

type ContainerInfo struct {
	PodNamespace  string
	PodName       string
	ContainerName string
}

func NewClient() *KubeClient {
	loadingRules := clientcmd.NewDefaultClientConfigLoadingRules()

	kubeConfig := clientcmd.NewNonInteractiveDeferredLoadingClientConfig(loadingRules, &clientcmd.ConfigOverrides{})
	config, err := kubeConfig.ClientConfig()
	if err != nil {
		logrus.WithError(err).Fatal("kubeconfig file could not be found!")
	}

	client, err := kubernetes.NewForConfig(config)
	if err != nil {
		logrus.WithError(err).Fatal("Could not create Kubernetes client from config!")
	}

	return &KubeClient{Client: client}
}

func (client *KubeClient) loadPods() error {
	list, err := client.Client.CoreV1().Pods("").List(context.Background(), meta.ListOptions{})

	if err != nil {
		logrus.WithError(err).Error("ListPods errored!")
		return err
	}

	client.pods = list.Items
	return nil
}

func (client *KubeClient) GetContainersWithImage(imageID string) ([]ContainerInfo, error) {
	if client.pods == nil {
		err := client.loadPods()

		if err != nil {
			return nil, err
		}
	}

	infos := make([]ContainerInfo, 0)

	for _, p := range client.pods {
		statuses := p.Status.ContainerStatuses
		statuses = append(statuses, p.Status.InitContainerStatuses...)
		statuses = append(statuses, p.Status.EphemeralContainerStatuses...)

		for _, c := range statuses {
			if c.ImageID == imageID {
				infos = append(infos, ContainerInfo{PodNamespace: p.Namespace, PodName: p.Name, ContainerName: c.Name})
			}
		}
	}

	return infos, nil
}

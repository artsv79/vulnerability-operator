package kubernetes

import (
	"context"

	"github.com/sirupsen/logrus"
	corev1 "k8s.io/api/core/v1"
	meta "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/tools/clientcmd"
)

type owner struct {
	kind string
	name string
}

type KubeClient struct {
	Client *kubernetes.Clientset
	pods   []corev1.Pod
	owners map[string]owner
}

type ContainerInfo struct {
	Namespace     string
	Name          string
	Kind          string
	ContainerName string
}

func NewClient() *KubeClient {
	loadingRules := clientcmd.NewDefaultClientConfigLoadingRules()

	kubeConfig := clientcmd.NewNonInteractiveDeferredLoadingClientConfig(loadingRules, &clientcmd.ConfigOverrides{})
	config, err := kubeConfig.ClientConfig()
	if err != nil {
		logrus.WithError(err).Fatal("kubeconfig file could not be found!")
	}

	client, err := kubernetes.NewForConfig(config)
	if err != nil {
		logrus.WithError(err).Fatal("Could not create Kubernetes client from config!")
	}

	return &KubeClient{Client: client, owners: make(map[string]owner)}
}

func (client *KubeClient) loadPods() error {
	list, err := client.Client.CoreV1().Pods("").List(context.Background(), meta.ListOptions{})

	if err != nil {
		logrus.WithError(err).Error("ListPods errored!")
		return err
	}

	client.pods = list.Items
	return nil
}

func (client *KubeClient) GetContainersWithImage(imageID string) ([]ContainerInfo, error) {
	if client.pods == nil {
		err := client.loadPods()

		if err != nil {
			return nil, err
		}
	}

	infos := make([]ContainerInfo, 0)

	for _, p := range client.pods {
		ref := p.Namespace + "/" + p.Name
		owner, ok := client.owners[ref]
		if !ok {
			owner = client.getOwner(p)
		}
		client.owners[ref] = owner

		statuses := p.Status.ContainerStatuses
		statuses = append(statuses, p.Status.InitContainerStatuses...)
		statuses = append(statuses, p.Status.EphemeralContainerStatuses...)

		for _, c := range statuses {
			if c.ImageID == imageID {
				infos = append(infos, ContainerInfo{Namespace: p.Namespace, Name: owner.name, Kind: owner.kind, ContainerName: c.Name})
			}
		}
	}

	return infos, nil
}

func (client *KubeClient) getOwner(pod corev1.Pod) owner {
	ownerKind, ownerName := getOwnerKindAndName(pod.OwnerReferences)
	ctx := context.Background()

	if ownerKind == "ReplicaSet" {
		rs, _ := client.Client.AppsV1().ReplicaSets(pod.Namespace).Get(ctx, ownerName, meta.GetOptions{})
		ownerKind, ownerName = getOwnerKindAndName(rs.OwnerReferences)
		if ownerKind == "Deployment" {
			dep, _ := client.Client.AppsV1().Deployments(pod.Namespace).Get(ctx, ownerName, meta.GetOptions{})
			return owner{kind: "Deployment", name: dep.Name}
		} else {
			return owner{kind: ownerKind, name: ownerName}
		}
	} else if ownerKind == "StatefulSet" {
		sts, _ := client.Client.AppsV1().StatefulSets(pod.Namespace).Get(ctx, ownerName, meta.GetOptions{})
		return owner{kind: "StatefulSet", name: sts.Name}
	} else if ownerKind == "DaemonSet" {
		ds, _ := client.Client.AppsV1().DaemonSets(pod.Namespace).Get(ctx, ownerName, meta.GetOptions{})
		return owner{kind: "DaemonSet", name: ds.Name}
	} else if ownerKind == "Job" {
		job, _ := client.Client.BatchV1().Jobs(pod.Namespace).Get(ctx, ownerName, meta.GetOptions{})
		ownerKind, ownerName = getOwnerKindAndName(job.OwnerReferences)
		if ownerKind == "" && ownerName == "" {
			return owner{kind: "Job", name: job.Name}
		} else {
			return owner{kind: ownerKind, name: ownerName}
		}
	} else if ownerKind != "" {
		// A CRD-Operator created the pod
		return owner{kind: ownerKind, name: ownerName}
	} else {
		// Single pod without owner
		return owner{kind: "Pod", name: pod.Name}
	}
}

func getOwnerKindAndName(refs []meta.OwnerReference) (string, string) {
	if len(refs) > 0 {
		return refs[0].Kind, refs[0].Name
	}

	return "", ""
}
